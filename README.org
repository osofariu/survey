* Survey 

- A Survey is made up of ordered Questions. The Survey tracks answers recorded for its questions, and determines which questions are active based on the optional condition associated with question.

- The /condition/ is a string, matching a lisp-style expression. It supports the following operations:
    
    - logical rules :: work on boolean expressions
        - and
        - or
        - not
    - comparison rules :: work with strings and numbers
        - equal (=)
        - less than (<)
        - greater than (>)
        - includes (array includes value)
    - answer :: look up answer; works with stings and numbers or arrays of them

- When the Survey records an answer for a Question it updates the state for the questions that follow it:
    - if a question changes its answer from what was previously recorded, the Survey re-evaluates all the following questions to see if their state needs to change
    - if question A depends on question B should A be active if B is inactive (even if the condition holds?) TBD

** Conditions

Conditions can be nested indefinitely as long as they conform to the grammar for this conditonal expression.

I should define the grammar more formally, but the few examples below will help illustrate what you can do with conditions.

*** equals, greater, less -- compares two string expressions

This is not very interesting when all arguments are literal values, but this is valid grammar

#+BEGIN_SRC js
    new Condition(new Survey()).evaluate("(= 'a' 'b')") == false
    new Condition(new Survey()).evaluate("(= 'a' 'a')" ) == true
#+END_SRC

**** with numeric comparisons

#+BEGIN_SRC js
    new Condition(new Survey()).evaluate("(> 100 99)") == true
    new Condition(new Survey()).evaluate("(<  99 100)" ) == true
#+END_SRC

*** not -- negates an expression that it wraps

#+BEGIN_SRC js
    const exp = "(not (= 'a' 'b'))"
    new Condition(new Survey()).evaluate(exp) == true
#+END_SRC

*** answer
    it needs to look up an answer in the survey and return the value

#+BEGIN_SRC js
    const question: Question = {
      tag: "q1",
    };
    const survey = new Survey().question(question);
    survey.recordAnswer('q1' 'hello')
    
    new Condition(survey).evaluate("(= (answer q1) 'hello')") == true
    new Condition(survey).evaluate("(= (answer q1) 'hellowse')") == false
#+END_SRC

**** This works with numbers too

#+BEGIN_SRC js
    const q1: Question = {tag: "q1"}
    const q2: Question = {tag: "q2", condition: "(> (answer q1) 100)"}
    const survey = new Survey().question(q1).question(q2);

    survey.questions[1].enabled == true
    survey.recordAnswer('q1' 100)
    survey.questions[1].enabled == false 
#+END_SRC

*** includes - similar to equal, but it looks up a string in a list of strings

To help out parsing the gammar I used a different lookup keyword: arrayAnswer instead of answer.  A bit less elegant, but not terrible.

#+BEGIN_SRC js
    // simple example:
    const exp1 = "(includes ['a', 'b'] 'b')"
    new Condition(new Survey()).evaluate(exp1) == true

    // with answer:
    const question: Question = {
      tag: "q1",
    };
    const survey = new Survey().question(question);
    survey.recordAnswer('q1', ['a', 'b'])

    const exp2 = "(includes (arrayAnswer q1) 'c')"
    new Condition(survey).evaluate(exp2) == false
#+END_SRC

*** and
    - expects two expressions
    - evaluates them left to right
    - stops the valuation if it detects false and returns false
    - this example pulls in multiple expressions to make it more interesting
#+BEGIN_SRC js
    const question1: Question = {
      tag: "q1",
      conditionExp: exp,
    };
    const question2: Question = {
      tag: "q2",
      conditionExp: exp,
    };
    const survey = new Survey().question(question1).question(question2);
    survey.recordAnswer('q1', 'hello')
    survey.recordAnswer('q2', 'there') 
    const exp = "(not (and (= (answer q1) "hello") (= 'there' (answer q2))))" 
    new Condition(survey).evaluate(exp) == false
#+END_SRC

*** or
    - expects two expressions
    - evaluates them left to right
    - stops the valuation if it detects true and returns true
