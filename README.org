* Survey 

** High-level introduction

This library is intended to track the state of a survey that has complex dependencies between its questions.  The main purpose is to enable or disable dependent questions as the user provides answers to questions.

In order to define the relationship between question we have introduced an /expression language/ that is just rich enough to give the user a flexible way to express relationships.  

** Key Features

- Rules are defined ahead of time, and provided to the /survey/.  This means that rules can be managed outside of code

- The /expression language/ for the rules is flexible and can arbitrarily complex, as long as they comply with the grammar.

- The /expression language/ is applied as a /condition/ string associated with each question.  Here are the high-level rules of the language:
    - logical rules (combine multiple expressions)
        - and
        - or
        - not
    - comparison rules (works with strings and numbers)
        - equal (for numbers and strings)
        - less than (for numbers)
        - greater than (for numbers)
        - includes (a value appears in a list of values)
        - isAnswered (a prior /question/ has been answer)
    - answer 
        - look up answer to a prior /question/ as a number, string, or array of numbers or strings

- The /survey/ disables dependent questions according to the following rules:
    - if the condition associated with a question evaluates to false, then the question becomes disabled
    - if a question becomes disabled then all the subsequent questions that *depend* on it also become disabled
        - a question /depends/ on another question if it mentions the other question somewhere in its conditional expression


** The Expression language

Conditions can be nested indefinitely as long as they conform to the grammar for this conditonal expression.

*** equals, greater, less -- compares two string expressions

This is not very interesting when all arguments are literal values, but this is valid grammar

#+BEGIN_SRC js
    new Condition(new Survey()).evaluate("(= 'a' 'b')") == false
    new Condition(new Survey()).evaluate("(= 'a' 'a')" ) == true
#+END_SRC

**** with numeric comparisons

#+BEGIN_SRC js
    new Condition(new Survey()).evaluate("(> 100 99)") == true
    new Condition(new Survey()).evaluate("(<  99 100)" ) == true
#+END_SRC

*** not -- negates an expression that it wraps

#+BEGIN_SRC js
    const exp = "(not (= 'a' 'b'))"
    new Condition(new Survey()).evaluate(exp) == true
#+END_SRC

*** isAnswered
    it checks if the question referenced has been answered

#+BEGIN_SRC js
    const survey = new Survey().question(buildQuestion({tag: "q1"}));
    new Condition(survey).evaluate("(isAnswered q1)") == false
    survey.recordAnswer('q1' 'hello')
    new Condition(survey).evaluate("(isAnswered q1)") == true
#+END_SRC

*** answer
    it looks up an answer in the /survey/ and return the value

#+BEGIN_SRC js
    const survey = new Survey().question(buildQuestion({tag: "q1"}));
    survey.recordAnswer('q1' 'hello')
    
    new Condition(survey).evaluate("(= (answer q1) 'hello')") == true
    new Condition(survey).evaluate("(= (answer q1) 'hellowse')") == false
#+END_SRC

**** This works with numbers too

#+BEGIN_SRC js
    const q1: Question = {tag: "q1"}
    const q2: Question = {tag: "q2", condition: "(> (answer q1) 100)"}
    const survey = new Survey().question(q1).question(q2);

    survey.questions[1].enabled == true
    survey.recordAnswer('q1' 100)
    survey.questions[1].enabled == false 
#+END_SRC

*** includes - similar to equal, but it looks up a string in a list of strings

To help out parsing the gammar I used a different lookup keyword: arrayAnswer instead of answer.  A bit less elegant, but not terrible.

#+BEGIN_SRC js
    // simple example:
    const exp1 = "(includes ['a', 'b'] 'b')"
    new Condition(new Survey()).evaluate(exp1) == true

    // with answer:
    const question: Question = {
      tag: "q1",
    };
    const survey = new Survey().question(question);
    survey.recordAnswer('q1', ['a', 'b'])

    const exp2 = "(includes (arrayAnswer q1) 'c')"
    new Condition(survey).evaluate(exp2) == false
#+END_SRC

*** and
    - expects two expressions
    - evaluates them left to right
    - stops the valuation if it detects false and returns false
    - this example pulls in multiple expressions to make it more interesting
#+BEGIN_SRC js
    const question1: Question = {
      tag: "q1",
      conditionExp: exp,
    };
    const question2: Question = {
      tag: "q2",
      conditionExp: exp,
    };
    const survey = new Survey().question(question1).question(question2);
    survey.recordAnswer('q1', 'hello')
    survey.recordAnswer('q2', 'there') 
    const exp = "(not (and (= (answer q1) "hello") (= 'there' (answer q2))))" 
    new Condition(survey).evaluate(exp) == false
#+END_SRC

*** or
    - expects two expressions
    - evaluates them left to right
    - stops the valuation if it detects true and returns true
